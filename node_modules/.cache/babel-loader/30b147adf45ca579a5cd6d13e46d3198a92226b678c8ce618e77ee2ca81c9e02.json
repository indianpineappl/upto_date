{"ast":null,"code":"var _LocationService;export class LocationService{constructor(){this.watchers=[];}static getInstance(){if(!LocationService.instance){LocationService.instance=new LocationService();}return LocationService.instance;}/**\n   * Get current location with high accuracy\n   */getCurrentLocation(){return new Promise((resolve,reject)=>{if(!navigator.geolocation){reject(new Error('Geolocation is not supported by this browser'));return;}navigator.geolocation.getCurrentPosition(position=>{resolve({latitude:position.coords.latitude,longitude:position.coords.longitude});},error=>{reject(new Error(\"Unable to retrieve location: \".concat(error.message)));},{enableHighAccuracy:true,timeout:10000,maximumAge:300000// 5 minutes\n});});}/**\n   * Watch position changes\n   */watchPosition(callback){if(!navigator.geolocation){throw new Error('Geolocation is not supported by this browser');}const watchId=navigator.geolocation.watchPosition(position=>{callback({latitude:position.coords.latitude,longitude:position.coords.longitude});},error=>{console.error('Error watching position:',error);},{enableHighAccuracy:true,timeout:10000,maximumAge:300000// 5 minutes\n});this.watchers.push(watchId);return watchId;}/**\n   * Stop watching a specific position\n   */clearWatch(watchId){navigator.geolocation.clearWatch(watchId);this.watchers=this.watchers.filter(id=>id!==watchId);}/**\n   * Stop watching all positions\n   */clearAllWatches(){this.watchers.forEach(id=>navigator.geolocation.clearWatch(id));this.watchers=[];}/**\n   * Reverse geocode coordinates to get city/country\n   */async reverseGeocode(lat,lng){// In a real implementation, this would call a geocoding API\n// For now, we'll return mock data\nconsole.warn('Reverse geocoding not implemented - returning mock data');return{city:'San Francisco',country:'USA'};}}_LocationService=LocationService;LocationService.instance=void 0;export default LocationService.getInstance();","map":{"version":3,"names":["LocationService","constructor","watchers","getInstance","instance","getCurrentLocation","Promise","resolve","reject","navigator","geolocation","Error","getCurrentPosition","position","latitude","coords","longitude","error","concat","message","enableHighAccuracy","timeout","maximumAge","watchPosition","callback","watchId","console","push","clearWatch","filter","id","clearAllWatches","forEach","reverseGeocode","lat","lng","warn","city","country","_LocationService"],"sources":["/Users/ab/CascadeProjects/Upto date app/src/services/locationService.ts"],"sourcesContent":["import { LocationData } from '../types';\n\nexport class LocationService {\n  private static instance: LocationService;\n  private watchers: number[] = [];\n  \n  private constructor() {}\n  \n  public static getInstance(): LocationService {\n    if (!LocationService.instance) {\n      LocationService.instance = new LocationService();\n    }\n    return LocationService.instance;\n  }\n  \n  /**\n   * Get current location with high accuracy\n   */\n  public getCurrentLocation(): Promise<LocationData> {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      \n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          resolve({\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n          });\n        },\n        (error) => {\n          reject(new Error(`Unable to retrieve location: ${error.message}`));\n        },\n        {\n          enableHighAccuracy: true,\n          timeout: 10000,\n          maximumAge: 300000, // 5 minutes\n        }\n      );\n    });\n  }\n  \n  /**\n   * Watch position changes\n   */\n  public watchPosition(callback: (location: LocationData) => void): number {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser');\n    }\n    \n    const watchId = navigator.geolocation.watchPosition(\n      (position) => {\n        callback({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n        });\n      },\n      (error) => {\n        console.error('Error watching position:', error);\n      },\n      {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000, // 5 minutes\n      }\n    );\n    \n    this.watchers.push(watchId);\n    return watchId;\n  }\n  \n  /**\n   * Stop watching a specific position\n   */\n  public clearWatch(watchId: number): void {\n    navigator.geolocation.clearWatch(watchId);\n    this.watchers = this.watchers.filter(id => id !== watchId);\n  }\n  \n  /**\n   * Stop watching all positions\n   */\n  public clearAllWatches(): void {\n    this.watchers.forEach(id => navigator.geolocation.clearWatch(id));\n    this.watchers = [];\n  }\n  \n  /**\n   * Reverse geocode coordinates to get city/country\n   */\n  public async reverseGeocode(lat: number, lng: number): Promise<{ city?: string; country?: string }> {\n    // In a real implementation, this would call a geocoding API\n    // For now, we'll return mock data\n    console.warn('Reverse geocoding not implemented - returning mock data');\n    return {\n      city: 'San Francisco',\n      country: 'USA'\n    };\n  }\n}\n\nexport default LocationService.getInstance();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}