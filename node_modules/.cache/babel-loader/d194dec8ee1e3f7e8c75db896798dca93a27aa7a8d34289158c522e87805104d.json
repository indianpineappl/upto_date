{"ast":null,"code":"var _LocationService;\nexport class LocationService {\n  constructor() {\n    this.watchers = [];\n  }\n  static getInstance() {\n    if (!LocationService.instance) {\n      LocationService.instance = new LocationService();\n    }\n    return LocationService.instance;\n  }\n\n  /**\n   * Get current location with high accuracy\n   */\n  getCurrentLocation() {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      navigator.geolocation.getCurrentPosition(position => {\n        resolve({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude\n        });\n      }, error => {\n        reject(new Error(`Unable to retrieve location: ${error.message}`));\n      }, {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000 // 5 minutes\n      });\n    });\n  }\n\n  /**\n   * Watch position changes\n   */\n  watchPosition(callback) {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser');\n    }\n    const watchId = navigator.geolocation.watchPosition(position => {\n      callback({\n        latitude: position.coords.latitude,\n        longitude: position.coords.longitude\n      });\n    }, error => {\n      console.error('Error watching position:', error);\n    }, {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 300000 // 5 minutes\n    });\n    this.watchers.push(watchId);\n    return watchId;\n  }\n\n  /**\n   * Stop watching a specific position\n   */\n  clearWatch(watchId) {\n    navigator.geolocation.clearWatch(watchId);\n    this.watchers = this.watchers.filter(id => id !== watchId);\n  }\n\n  /**\n   * Stop watching all positions\n   */\n  clearAllWatches() {\n    this.watchers.forEach(id => navigator.geolocation.clearWatch(id));\n    this.watchers = [];\n  }\n\n  /**\n   * Reverse geocode coordinates to get city/country\n   */\n  async reverseGeocode(lat, lng) {\n    // In a real implementation, this would call a geocoding API\n    // For now, we'll return mock data\n    console.warn('Reverse geocoding not implemented - returning mock data');\n    return {\n      city: 'San Francisco',\n      country: 'USA'\n    };\n  }\n}\n_LocationService = LocationService;\nLocationService.instance = void 0;\nexport default LocationService.getInstance();","map":{"version":3,"names":["LocationService","constructor","watchers","getInstance","instance","getCurrentLocation","Promise","resolve","reject","navigator","geolocation","Error","getCurrentPosition","position","latitude","coords","longitude","error","message","enableHighAccuracy","timeout","maximumAge","watchPosition","callback","watchId","console","push","clearWatch","filter","id","clearAllWatches","forEach","reverseGeocode","lat","lng","warn","city","country","_LocationService"],"sources":["/Users/ab/CascadeProjects/Upto date app/src/services/locationService.ts"],"sourcesContent":["import { LocationData } from '../types';\n\nexport class LocationService {\n  private static instance: LocationService;\n  private watchers: number[] = [];\n  \n  private constructor() {}\n  \n  public static getInstance(): LocationService {\n    if (!LocationService.instance) {\n      LocationService.instance = new LocationService();\n    }\n    return LocationService.instance;\n  }\n  \n  /**\n   * Get current location with high accuracy\n   */\n  public getCurrentLocation(): Promise<LocationData> {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported by this browser'));\n        return;\n      }\n      \n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          resolve({\n            latitude: position.coords.latitude,\n            longitude: position.coords.longitude,\n          });\n        },\n        (error) => {\n          reject(new Error(`Unable to retrieve location: ${error.message}`));\n        },\n        {\n          enableHighAccuracy: true,\n          timeout: 10000,\n          maximumAge: 300000, // 5 minutes\n        }\n      );\n    });\n  }\n  \n  /**\n   * Watch position changes\n   */\n  public watchPosition(callback: (location: LocationData) => void): number {\n    if (!navigator.geolocation) {\n      throw new Error('Geolocation is not supported by this browser');\n    }\n    \n    const watchId = navigator.geolocation.watchPosition(\n      (position) => {\n        callback({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n        });\n      },\n      (error) => {\n        console.error('Error watching position:', error);\n      },\n      {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000, // 5 minutes\n      }\n    );\n    \n    this.watchers.push(watchId);\n    return watchId;\n  }\n  \n  /**\n   * Stop watching a specific position\n   */\n  public clearWatch(watchId: number): void {\n    navigator.geolocation.clearWatch(watchId);\n    this.watchers = this.watchers.filter(id => id !== watchId);\n  }\n  \n  /**\n   * Stop watching all positions\n   */\n  public clearAllWatches(): void {\n    this.watchers.forEach(id => navigator.geolocation.clearWatch(id));\n    this.watchers = [];\n  }\n  \n  /**\n   * Reverse geocode coordinates to get city/country\n   */\n  public async reverseGeocode(lat: number, lng: number): Promise<{ city?: string; country?: string }> {\n    // In a real implementation, this would call a geocoding API\n    // For now, we'll return mock data\n    console.warn('Reverse geocoding not implemented - returning mock data');\n    return {\n      city: 'San Francisco',\n      country: 'USA'\n    };\n  }\n}\n\nexport default LocationService.getInstance();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}