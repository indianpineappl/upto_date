{"ast":null,"code":"var _PreferenceService;\n// Mock implementation for demonstration\n// In a real implementation, this would use localStorage or a backend database\n\nexport class PreferenceService {\n  constructor() {\n    this.storageKey = 'uptodate_preferences';\n  }\n  static getInstance() {\n    if (!PreferenceService.instance) {\n      PreferenceService.instance = new PreferenceService();\n    }\n    return PreferenceService.instance;\n  }\n\n  /**\n   * Save user preferences to storage\n   */\n  savePreferences(preferences) {\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(preferences));\n    } catch (error) {\n      console.error('Failed to save preferences:', error);\n    }\n  }\n\n  /**\n   * Load user preferences from storage\n   */\n  loadPreferences() {\n    try {\n      const preferences = localStorage.getItem(this.storageKey);\n      return preferences ? JSON.parse(preferences) : [];\n    } catch (error) {\n      console.error('Failed to load preferences:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Add a new preference\n   */\n  addPreference(preference) {\n    const preferences = this.loadPreferences();\n    // Remove existing preference for this topic\n    const filtered = preferences.filter(p => p.topicId !== preference.topicId);\n    // Add new preference\n    const updated = [...filtered, preference];\n    this.savePreferences(updated);\n  }\n\n  /**\n   * Calculate topic score based on user preferences\n   */\n  calculateTopicScore(topicId) {\n    const preferences = this.loadPreferences();\n    const topicPreferences = preferences.filter(p => p.topicId === topicId);\n    if (topicPreferences.length === 0) {\n      return 0; // Neutral score\n    }\n\n    // Calculate weighted average, giving more weight to recent preferences\n    const now = Date.now();\n    let totalScore = 0;\n    let totalWeight = 0;\n    topicPreferences.forEach(pref => {\n      // Weight decreases as preference gets older (7 days half-life)\n      const ageInDays = (now - pref.timestamp) / (1000 * 60 * 60 * 24);\n      const weight = Math.pow(0.5, ageInDays / 7);\n      totalScore += pref.preferenceScore * weight;\n      totalWeight += weight;\n    });\n    return totalWeight > 0 ? totalScore / totalWeight : 0;\n  }\n\n  /**\n   * Get all topic scores\n   */\n  getAllTopicScores() {\n    const preferences = this.loadPreferences();\n    const topicScores = {};\n\n    // Get unique topic IDs\n    const topicIds = Array.from(new Set(preferences.map(p => p.topicId)));\n\n    // Calculate score for each topic\n    topicIds.forEach(topicId => {\n      topicScores[topicId] = this.calculateTopicScore(topicId);\n    });\n    return topicScores;\n  }\n\n  /**\n   * Clear all preferences\n   */\n  clearPreferences() {\n    try {\n      localStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.error('Failed to clear preferences:', error);\n    }\n  }\n}\n_PreferenceService = PreferenceService;\nPreferenceService.instance = void 0;\nexport default PreferenceService.getInstance();","map":{"version":3,"names":["PreferenceService","constructor","storageKey","getInstance","instance","savePreferences","preferences","localStorage","setItem","JSON","stringify","error","console","loadPreferences","getItem","parse","addPreference","preference","filtered","filter","p","topicId","updated","calculateTopicScore","topicPreferences","length","now","Date","totalScore","totalWeight","forEach","pref","ageInDays","timestamp","weight","Math","pow","preferenceScore","getAllTopicScores","topicScores","topicIds","Array","from","Set","map","clearPreferences","removeItem","_PreferenceService"],"sources":["/Users/ab/CascadeProjects/Upto date app/src/services/preferenceService.ts"],"sourcesContent":["// Mock implementation for demonstration\n// In a real implementation, this would use localStorage or a backend database\n\nimport { UserPreference } from '../types';\n\nexport class PreferenceService {\n  private static instance: PreferenceService;\n  private storageKey = 'uptodate_preferences';\n  \n  private constructor() {}\n  \n  public static getInstance(): PreferenceService {\n    if (!PreferenceService.instance) {\n      PreferenceService.instance = new PreferenceService();\n    }\n    return PreferenceService.instance;\n  }\n  \n  /**\n   * Save user preferences to storage\n   */\n  public savePreferences(preferences: UserPreference[]): void {\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(preferences));\n    } catch (error) {\n      console.error('Failed to save preferences:', error);\n    }\n  }\n  \n  /**\n   * Load user preferences from storage\n   */\n  public loadPreferences(): UserPreference[] {\n    try {\n      const preferences = localStorage.getItem(this.storageKey);\n      return preferences ? JSON.parse(preferences) : [];\n    } catch (error) {\n      console.error('Failed to load preferences:', error);\n      return [];\n    }\n  }\n  \n  /**\n   * Add a new preference\n   */\n  public addPreference(preference: UserPreference): void {\n    const preferences = this.loadPreferences();\n    // Remove existing preference for this topic\n    const filtered = preferences.filter(p => p.topicId !== preference.topicId);\n    // Add new preference\n    const updated = [...filtered, preference];\n    this.savePreferences(updated);\n  }\n  \n  /**\n   * Calculate topic score based on user preferences\n   */\n  public calculateTopicScore(topicId: string): number {\n    const preferences = this.loadPreferences();\n    const topicPreferences = preferences.filter(p => p.topicId === topicId);\n    \n    if (topicPreferences.length === 0) {\n      return 0; // Neutral score\n    }\n    \n    // Calculate weighted average, giving more weight to recent preferences\n    const now = Date.now();\n    let totalScore = 0;\n    let totalWeight = 0;\n    \n    topicPreferences.forEach(pref => {\n      // Weight decreases as preference gets older (7 days half-life)\n      const ageInDays = (now - pref.timestamp) / (1000 * 60 * 60 * 24);\n      const weight = Math.pow(0.5, ageInDays / 7);\n      \n      totalScore += pref.preferenceScore * weight;\n      totalWeight += weight;\n    });\n    \n    return totalWeight > 0 ? totalScore / totalWeight : 0;\n  }\n  \n  /**\n   * Get all topic scores\n   */\n  public getAllTopicScores(): Record<string, number> {\n    const preferences = this.loadPreferences();\n    const topicScores: Record<string, number> = {};\n    \n    // Get unique topic IDs\n    const topicIds = Array.from(new Set(preferences.map(p => p.topicId)));\n    \n    // Calculate score for each topic\n    topicIds.forEach(topicId => {\n      topicScores[topicId] = this.calculateTopicScore(topicId);\n    });\n    \n    return topicScores;\n  }\n  \n  /**\n   * Clear all preferences\n   */\n  public clearPreferences(): void {\n    try {\n      localStorage.removeItem(this.storageKey);\n    } catch (error) {\n      console.error('Failed to clear preferences:', error);\n    }\n  }\n}\n\nexport default PreferenceService.getInstance();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}